import streamlit as st
import pandas as pd
import io
from datetime import datetime
import pyxlsb

# Konfiguracja strony
st.set_page_config(
    page_title="Przetwarzanie plik√≥w Excel",
    page_icon="üìä",
    layout="wide"
)

# Tytu≈Ç aplikacji
st.title("üìä :dagger: No≈ºyk App :dagger:")


st.markdown("---")


def fix_problematic_columns(df):
    """Naprawia problematyczne kolumny w DataFrame"""
    # Lista znanych problematycznych kolumn
    problematic_columns = ['Street Num', 'Numer', 'Postal', 'Exception',
                           'OPLD Consignee Name', 'Consignee Name', 'Consignee']

    # Sprawd≈∫ wszystkie kolumny pod kƒÖtem mieszanych typ√≥w
    for col in df.columns:
        try:
            # Sprawd≈∫ czy kolumna ma mieszane typy danych
            if df[col].dtype == 'object':
                # Sprawd≈∫ czy sƒÖ r√≥≈ºne typy w kolumnie
                non_null_values = df[col].dropna()
                if len(non_null_values) > 0:
                    types_in_col = non_null_values.apply(type).unique()
                    if len(types_in_col) > 1:
                        # Konwertuj wszystko na string
                        df[col] = df[col].astype(str)
        except Exception:
            # Je≈õli nie mo≈ºna sprawdziƒá typ√≥w, po prostu konwertuj na string
            try:
                df[col] = df[col].astype(str)
            except Exception:
                pass

    # Konwertuj znane problematyczne kolumny
    for col in problematic_columns:
        if col in df.columns:
            try:
                df[col] = df[col].astype(str)
            except Exception:
                pass

    return df


def extract_driver_name(driver_id):
    """WyciƒÖga czƒô≈õƒá nazwy Driver ID od 6 do 8 znaku"""
    driver_str = str(driver_id)
    if len(driver_str) >= 8:
        return driver_str[5:8]  # od 6 do 8 znaku (indeksy 5-7)
    elif len(driver_str) >= 5:
        return driver_str[5:]   # od 6 znaku do ko≈Ñca
    else:
        return driver_str       # ca≈Ça nazwa je≈õli kr√≥tsza ni≈º 5 znak√≥w


# Funkcja do ≈Çadowania pliku Excel
@st.cache_data
def load_excel_file(file):
    """≈Åaduje plik Excel i zwraca s≈Çownik z arkuszami"""
    try:
        # Sprawd≈∫ rozszerzenie pliku
        file_extension = file.name.split('.')[-1].lower()

        if file_extension == 'xlsb':
            # Obs≈Çuga plik√≥w .xlsb
            sheets_dict = {}
            with pyxlsb.open_workbook(file) as wb:
                for sheet_name in wb.sheets:
                    try:
                        dataframe = pd.read_excel(
                            file, sheet_name=sheet_name, engine='pyxlsb')
                        # Napraw problematyczne kolumny
                        dataframe = fix_problematic_columns(dataframe)
                        sheets_dict[sheet_name] = dataframe
                    except Exception as e:
                        st.warning(
                            f"‚ö†Ô∏è Problem z arkuszem {sheet_name}: {str(e)}")
                        # Spr√≥buj za≈Çadowaƒá z domy≈õlnymi ustawieniami
                        try:
                            dataframe = pd.read_excel(
                                file, sheet_name=sheet_name, engine='pyxlsb', dtype=str)
                            sheets_dict[sheet_name] = dataframe
                        except Exception:
                            st.error(
                                f"‚ùå Nie uda≈Ço siƒô za≈Çadowaƒá arkusza {sheet_name}")
            return sheets_dict
        else:
            # Obs≈Çuga plik√≥w .xlsx i .xls
            excel_file = pd.ExcelFile(file)
            sheets_dict = {}

            for sheet_name in excel_file.sheet_names:
                try:
                    dataframe = pd.read_excel(file, sheet_name=sheet_name)
                    # Napraw problematyczne kolumny
                    dataframe = fix_problematic_columns(dataframe)
                    sheets_dict[sheet_name] = dataframe
                except Exception as e:
                    st.warning(f"‚ö†Ô∏è Problem z arkuszem {sheet_name}: {str(e)}")
                    # Spr√≥buj za≈Çadowaƒá z domy≈õlnymi ustawieniami
                    try:
                        dataframe = pd.read_excel(
                            file, sheet_name=sheet_name, dtype=str)
                        sheets_dict[sheet_name] = dataframe
                    except Exception:
                        st.error(
                            f"‚ùå Nie uda≈Ço siƒô za≈Çadowaƒá arkusza {sheet_name}")

            return sheets_dict
    except (ValueError, FileNotFoundError, PermissionError) as e:
        st.error(f"B≈ÇƒÖd podczas ≈Çadowania pliku: {str(e)}")
        return None


# Sidebar - ≈Çadowanie pliku
st.sidebar.header("üìÅ ≈Åadowanie pliku")

# Przycisk do czyszczenia cache'a
if st.sidebar.button("üóëÔ∏è Wyczy≈õƒá cache", help="Usu≈Ñ za≈Çadowane dane z pamiƒôci"):
    if 'cached_file_key' in st.session_state:
        del st.session_state.cached_file_key
    if 'cached_sheets_data' in st.session_state:
        del st.session_state.cached_sheets_data
    st.sidebar.success("‚úÖ Cache wyczyszczony!")
    st.rerun()

uploaded_file = st.sidebar.file_uploader(
    "Wybierz plik Excel",
    type=None,  # Pozw√≥l na wszystkie typy plik√≥w
    accept_multiple_files=False,
    help="Obs≈Çugiwane formaty: .xlsx, .xls, .xlsb"
)

if uploaded_file is not None:
    # Sprawd≈∫ rozszerzenie pliku
    file_extension = uploaded_file.name.split('.')[-1].lower()
    if file_extension not in ['xlsx', 'xls', 'xlsb']:
        st.error(
            f"‚ùå Nieobs≈Çugiwany format pliku: .{file_extension}. Obs≈Çugiwane formaty: .xlsx, .xls, .xlsb")
    else:
        # Sprawd≈∫ czy plik jest ju≈º w cache
        file_key = f"{uploaded_file.name}_{uploaded_file.size}"

        if 'cached_file_key' not in st.session_state or st.session_state.cached_file_key != file_key:
            # ≈Åadowanie danych
            with st.spinner("≈Åadowanie pliku..."):
                sheets_data = load_excel_file(uploaded_file)

            if sheets_data:
                st.success(
                    f"‚úÖ Plik za≈Çadowany pomy≈õlnie! Znaleziono {len(sheets_data)} arkuszy.")
                # Zapisz w session state
                st.session_state.cached_file_key = file_key
                st.session_state.cached_sheets_data = sheets_data
            else:
                st.error("‚ùå Nie uda≈Ço siƒô za≈Çadowaƒá pliku.")
                sheets_data = None
        else:
            # U≈ºyj danych z cache
            sheets_data = st.session_state.cached_sheets_data
            st.success(
                f"‚úÖ Plik za≈Çadowany z cache! Znaleziono {len(sheets_data)} arkuszy.")

        if sheets_data:
            # Automatycznie wybierz pierwszy arkusz
            first_sheet = list(sheets_data.keys())[0]
            df = sheets_data[first_sheet]

            # Konwertuj daty i czas przed filtrowaniem
            for col in df.columns:
                if col.upper() == 'DATA' and pd.api.types.is_numeric_dtype(df[col]):
                    # Konwertuj daty Excel na prawid≈Çowe daty
                    df[col] = pd.to_datetime(
                        '1900-01-01') + pd.to_timedelta(df[col] - 2, unit='D')
                elif col.upper() == 'TIME' and pd.api.types.is_numeric_dtype(df[col]):
                    # Konwertuj czas Excel na prawid≈Çowy czas
                    df[col] = pd.to_datetime(
                        '1900-01-01') + pd.to_timedelta(df[col], unit='D')
                    df[col] = df[col].dt.time

            # Napraw problematyczne kolumny dla Streamlit (dodatkowa naprawa)
            df = fix_problematic_columns(df)

            # Sprawd≈∫ czy istnieje kolumna "Driver ID:"
            if 'Driver ID:' in df.columns:
                # Kalendarz
                st.sidebar.markdown("---")
                st.sidebar.header("üìÖ Wyb√≥r dat")

                # Znajd≈∫ kolumnƒô z datami
                date_column = None
                for col in df.columns:
                    if col.upper() == 'DATA' or 'date' in col.lower():
                        date_column = col
                        break

                if date_column is not None:
                    try:
                        # Pobierz zakres dat z danych
                        min_date = df[date_column].min().date()
                        max_date = df[date_column].max().date()

                        # Opcje wyboru dat
                        # Inicjalizuj session state dla zapamiƒôtywania wyboru dat
                        if 'date_option' not in st.session_state:
                            st.session_state.date_option = "Wszystkie daty"

                        # Przygotuj listƒô opcji dat
                        date_options = ["Wszystkie daty",
                                        "Tylko soboty", "Niestandardowy wyb√≥r"]

                        # Znajd≈∫ indeks dla zapamiƒôtanego wyboru
                        try:
                            date_index = date_options.index(
                                st.session_state.date_option)
                        except ValueError:
                            date_index = 0

                        date_option = st.sidebar.radio(
                            "Wybierz opcjƒô dat:",
                            date_options,
                            index=date_index,
                            help="Wyb√≥r zostanie zapamiƒôtany"
                        )

                        # Zapisz wyb√≥r w session state
                        st.session_state.date_option = date_option

                        if date_option == "Tylko soboty":
                            # Filtruj tylko soboty
                            # 5 = sobota
                            df = df[df[date_column].dt.dayofweek == 5]
                            st.sidebar.success(
                                f"üìÖ Wy≈õwietlane tylko soboty: {len(df)} wierszy")
                        elif date_option == "Niestandardowy wyb√≥r":
                            # Kalendarz z mo≈ºliwo≈õciƒÖ zaznaczenia dni
                            selected_dates = st.sidebar.date_input(
                                "Wybierz daty:",
                                value=(min_date, max_date),
                                min_value=min_date,
                                max_value=max_date,
                                help="Mo≈ºesz wybraƒá pojedynczy dzie≈Ñ lub zakres dat"
                            )

                            # Filtruj dane wed≈Çug wybranych dat
                            if isinstance(selected_dates, tuple) and len(selected_dates) == 2:
                                start_date, end_date = selected_dates
                                df = df[(df[date_column].dt.date >= start_date) & (
                                    df[date_column].dt.date <= end_date)]
                            elif selected_dates:
                                df = df[df[date_column].dt.date ==
                                        selected_dates]

                            st.sidebar.success(
                                f"üìÖ Filtrowanie wed≈Çug dat: {len(df)} wierszy")
                        else:
                            st.sidebar.info("üìÖ Wy≈õwietlane wszystkie daty")

                    except Exception as e:
                        st.sidebar.error(
                            f"‚ùå B≈ÇƒÖd podczas przetwarzania dat: {str(e)}")
                else:
                    st.sidebar.warning("‚ö†Ô∏è Nie znaleziono kolumny z datami")

                # Wyb√≥r driver id
                st.sidebar.markdown("---")
                st.sidebar.header("üöó Wyb√≥r Driver ID")
                unique_drivers = df['Driver ID:'].dropna().unique()

                # WyciƒÖgnij czƒô≈õƒá nazwy od 5 do 8 znaku dla lepszej czytelno≈õci
                # Stw√≥rz mapowanie oryginalnych nazw na skr√≥cone
                driver_mapping = {}
                for driver_id in unique_drivers:
                    short_name = extract_driver_name(driver_id)
                    driver_mapping[short_name] = driver_id

                # Inicjalizuj session state dla zapamiƒôtywania wyboru Driver ID
                if 'selected_driver' not in st.session_state:
                    st.session_state.selected_driver = 'Wszyscy'

                # Sprawd≈∫ czy poprzedni wyb√≥r jest nadal dostƒôpny
                if st.session_state.selected_driver not in ['Wszyscy'] + list(driver_mapping.keys()):
                    st.session_state.selected_driver = 'Wszyscy'

                # Przygotuj listƒô opcji - posortuj skr√≥cone nazwy Driver ID alfabetycznie
                sorted_drivers = sorted(driver_mapping.keys())

                driver_options = ['Wszyscy'] + list(sorted_drivers)

                # Znajd≈∫ indeks dla zapamiƒôtanego wyboru
                try:
                    default_index = driver_options.index(
                        st.session_state.selected_driver)
                except ValueError:
                    default_index = 0

                selected_driver = st.sidebar.selectbox(
                    "Wybierz Driver ID:",
                    options=driver_options,
                    index=default_index,
                    help="Wyb√≥r zostanie zapamiƒôtany"
                )

                # Zapisz wyb√≥r w session state
                st.session_state.selected_driver = selected_driver

                # Filtruj dane wed≈Çug wybranego driver id
                if selected_driver != 'Wszyscy':
                    # U≈ºyj oryginalnej nazwy Driver ID do filtrowania
                    original_driver_id = driver_mapping[selected_driver]
                    df = df[df['Driver ID:'] == original_driver_id]
                    st.info(
                        f"üìä Wy≈õwietlane dane dla Driver ID: {original_driver_id} (skr√≥cone: {selected_driver})")
                else:
                    st.info("üìä Wy≈õwietlane dane dla wszystkich kierowc√≥w")

                # Wyb√≥r Exception Info
                st.sidebar.markdown("---")
                st.sidebar.header("‚ö†Ô∏è Exception info")

                # Sprawd≈∫ czy istnieje kolumna Exception Info
                if 'Exception info' in df.columns:
                    # Zahardkodowane warto≈õci do wyboru
                    hardcoded_exceptions = [
                        "DR RELEASED", "COMM INS REL", "SIG OBTAINED"]

                    # Sprawd≈∫ kt√≥re z zahardkodowanych warto≈õci sƒÖ dostƒôpne w danych
                    available_hardcoded = [
                        exc for exc in hardcoded_exceptions if exc in df['Exception info'].values]

                    if available_hardcoded:
                        # Inicjalizuj session state dla zapamiƒôtywania wyboru - zawsze wszystkie dostƒôpne warto≈õci
                        if 'selected_exceptions' not in st.session_state:
                            st.session_state.selected_exceptions = available_hardcoded

                        # Sprawd≈∫ czy poprzednie wybory sƒÖ nadal dostƒôpne
                        available_exceptions = [
                            exc for exc in st.session_state.selected_exceptions if exc in available_hardcoded]

                        selected_exceptions = st.sidebar.multiselect(
                            "Wybierz warto≈õci Exception info:",
                            options=available_hardcoded,
                            default=available_hardcoded,  # Zawsze wszystkie zaznaczone domy≈õlnie
                            help="Wszystkie warto≈õci sƒÖ domy≈õlnie zaznaczone. Mo≈ºesz odznaczyƒá niekt√≥re."
                        )

                        # Zapisz wyb√≥r w session state
                        st.session_state.selected_exceptions = selected_exceptions

                        if selected_exceptions:
                            # Filtruj dane wed≈Çug wybranych warto≈õci
                            df = df[df['Exception info'].isin(
                                selected_exceptions)]
                            st.info(
                                f"‚ö†Ô∏è Wy≈õwietlane wiersze z Exception info: {', '.join(selected_exceptions)}")

                        else:
                            st.info("‚ö†Ô∏è Wy≈õwietlane wszystkie wiersze")
                    else:
                        st.sidebar.warning(
                            "‚ö†Ô∏è Brak zahardkodowanych warto≈õci w kolumnie Exception info")
                        st.sidebar.info(
                            f"üí° Dostƒôpne warto≈õci: {', '.join(df['Exception info'].dropna().unique()[:5])}...")
                else:
                    st.sidebar.warning(
                        "‚ö†Ô∏è Nie znaleziono kolumny 'Exception info'")
            else:
                st.warning("‚ö†Ô∏è Nie znaleziono kolumny 'Driver ID:' w danych")
                st.info("üìä Wy≈õwietlane wszystkie dane")
                selected_driver = 'Wszyscy'

            # Informacje o danych
            st.sidebar.markdown("---")
            st.sidebar.header("‚ÑπÔ∏è Informacje o danych")
            st.sidebar.metric("Liczba wierszy", len(df))
            st.sidebar.metric("Liczba kolumn", len(df.columns))

            # Wy≈õwietl statystyki Exception info i City Name nad Driver ID
        if 'Exception info' in df.columns:
            exception_counts = df['Exception info'].value_counts()
            total_exceptions = len(
                df[df['Exception info'].notna() & (df['Exception info'] != '')])

            col1, col2, col3 = st.columns([2, 2, 1])

            with col1:
                st.metric("Exception info (filtrowane)", total_exceptions)
                if len(exception_counts) > 0:
                    st.caption(
                        f"Top: {exception_counts.index[0]} ({exception_counts.iloc[0]})")

            with col2:
                # Statystyki City Name - liczenie unikalnych adres√≥w z datƒÖ
                if 'City Name' in df.columns:
                    # Sprawd≈∫ czy wszystkie wymagane kolumny adresowe istniejƒÖ
                    address_columns = [
                        'Postal', 'City Name', 'Street Name', 'Street Num']
                    available_address_columns = [
                        col for col in address_columns if col in df.columns]

                    # Znajd≈∫ kolumnƒô z datƒÖ
                    date_column = None
                    for col in df.columns:
                        if col.upper() == 'DATA' or 'date' in col.lower():
                            date_column = col
                            break

                    # Minimum City Name + jedna inna kolumna adresowa
                    if len(available_address_columns) >= 2:
                        # Utw√≥rz unikalne kombinacje adres√≥w + data
                        if date_column and len(available_address_columns) == 4:
                            # Wszystkie kolumny adresowe + data dostƒôpne
                            unique_columns = address_columns + \
                                [date_column]
                            unique_addresses = df[unique_columns].drop_duplicates(
                            )
                        elif date_column:
                            # Tylko dostƒôpne kolumny + data
                            unique_columns = available_address_columns + \
                                [date_column]
                            unique_addresses = df[unique_columns].drop_duplicates(
                            )
                        elif len(available_address_columns) == 4:
                            # Wszystkie kolumny adresowe bez daty
                            unique_addresses = df[address_columns].drop_duplicates(
                            )
                        else:
                            # Tylko dostƒôpne kolumny bez daty
                            unique_addresses = df[available_address_columns].drop_duplicates(
                            )

                        # Policz miasta w unikalnych adresach
                        city_counts = unique_addresses['City Name'].value_counts(
                        )
                        wroclaw_count = city_counts.get('WROCLAW', 0)
                        other_count = len(unique_addresses) - wroclaw_count

                        st.metric("WROCLAW (unikalne adresy)",
                                  wroclaw_count)
                        st.metric(
                            "Inne miasta (unikalne adresy)", other_count)
                        if date_column:
                            st.caption(
                                f"≈ÅƒÖcznie unikalnych adres√≥w z datƒÖ: {len(unique_addresses)}")
                        else:
                            st.caption(
                                f"≈ÅƒÖcznie unikalnych adres√≥w: {len(unique_addresses)}")
                    else:
                        # Fallback - liczenie bezpo≈õrednio z City Name
                        city_counts = df['City Name'].value_counts()
                        wroclaw_count = city_counts.get('WROCLAW', 0)
                        other_count = len(df) - wroclaw_count

                        st.metric("WROCLAW", wroclaw_count)
                        st.metric("Wioski", other_count)
                        st.caption("‚ö†Ô∏è Brak pe≈Çnych danych adresowych")
                else:
                    st.info("Brak kolumny 'City Name'")

            with col3:
                st.empty()  # Pusty placeholder

            # G≈Ç√≥wna zawarto≈õƒá
            col1, col2 = st.columns([3, 1])

            with col1:
                if 'Driver ID:' in df.columns and selected_driver != 'Wszyscy':
                    st.header(f"üìä Driver ID: {selected_driver}")

                    # PodglƒÖd danych
                    st.subheader("PodglƒÖd danych")
                    st.dataframe(df.head(10), use_container_width=True)
                else:
                    st.header("üìä Podsumowanie dla wszystkich kierowc√≥w")

                    # Tabela podsumowujƒÖca dla wszystkich kierowc√≥w
                    if 'Driver ID:' in df.columns:
                        # Przygotuj dane do podsumowania
                        summary_data = []

                        for driver_id in df['Driver ID:'].dropna().unique():
                            driver_df = df[df['Driver ID:'] == driver_id]

                            # Liczba wyjƒÖtk√≥w
                            exception_count = len(driver_df[driver_df['Exception info'].notna() & (
                                driver_df['Exception info'] != '')])

                            # Statystyki miast
                            if 'City Name' in driver_df.columns:
                                # Sprawd≈∫ czy wszystkie wymagane kolumny adresowe istniejƒÖ
                                address_columns = [
                                    'Postal', 'City Name', 'Street Name', 'Street Num']
                                available_address_columns = [
                                    col for col in address_columns if col in driver_df.columns]

                                # Znajd≈∫ kolumnƒô z datƒÖ
                                date_column = None
                                for col in driver_df.columns:
                                    if col.upper() == 'DATA' or 'date' in col.lower():
                                        date_column = col
                                        break

                                # Minimum City Name + jedna inna kolumna adresowa
                                if len(available_address_columns) >= 2:
                                    # Utw√≥rz unikalne kombinacje adres√≥w + data
                                    if date_column and len(available_address_columns) == 4:
                                        # Wszystkie kolumny adresowe + data dostƒôpne
                                        unique_columns = address_columns + \
                                            [date_column]
                                        unique_addresses = driver_df[unique_columns].drop_duplicates(
                                        )
                                    elif date_column:
                                        # Tylko dostƒôpne kolumny + data
                                        unique_columns = available_address_columns + \
                                            [date_column]
                                        unique_addresses = driver_df[unique_columns].drop_duplicates(
                                        )
                                    elif len(available_address_columns) == 4:
                                        # Wszystkie kolumny adresowe bez daty
                                        unique_addresses = driver_df[address_columns].drop_duplicates(
                                        )
                                    else:
                                        # Tylko dostƒôpne kolumny bez daty
                                        unique_addresses = driver_df[available_address_columns].drop_duplicates(
                                        )

                                    # Policz miasta w unikalnych adresach
                                    city_counts = unique_addresses['City Name'].value_counts(
                                    )
                                    wroclaw_count = city_counts.get(
                                        'WROCLAW', 0)
                                    other_count = len(
                                        unique_addresses) - wroclaw_count
                                else:
                                    # Fallback - liczenie bezpo≈õrednio z City Name
                                    city_counts = driver_df['City Name'].value_counts(
                                    )
                                    wroclaw_count = city_counts.get(
                                        'WROCLAW', 0)
                                    other_count = len(
                                        driver_df) - wroclaw_count
                            else:
                                wroclaw_count = 0
                                other_count = 0

                            # Dodaj dane do podsumowania z skr√≥conƒÖ nazwƒÖ Driver ID
                            short_driver_id = extract_driver_name(driver_id)
                            summary_data.append({
                                # Skr√≥cona nazwa + oryginalna w nawiasach
                                'Driver ID': f"{short_driver_id} ({driver_id})",
                                'Exception Count': exception_count,
                                'WROCLAW': wroclaw_count,
                                'Wioski': other_count,
                                'Total Rows': len(driver_df)
                            })

                        # Utw√≥rz DataFrame z podsumowaniem
                        summary_df = pd.DataFrame(summary_data)

                        # Sortuj wed≈Çug skr√≥conych nazw Driver ID alfabetycznie
                        summary_df['Driver ID_short'] = summary_df['Driver ID'].apply(
                            lambda x: x.split(' (')[0] if ' (' in str(x) else str(x))
                        summary_df = summary_df.sort_values(
                            'Driver ID_short').drop('Driver ID_short', axis=1)

                        # Wy≈õwietl tabelƒô podsumowujƒÖcƒÖ
                        st.subheader("üìã Podsumowanie kierowc√≥w")
                        st.dataframe(summary_df, use_container_width=True)

                        # Dodaj przycisk eksportu tabeli podsumowujƒÖcej
                        st.subheader("üíæ Eksport podsumowania")
                        col_export1, col_export2 = st.columns(2)

                        with col_export1:
                            if st.button("üì• Pobierz podsumowanie (CSV)"):
                                csv_summary = summary_df.to_csv(index=False)
                                st.download_button(
                                    label="üì• Pobierz CSV",
                                    data=csv_summary,
                                    file_name=f"podsumowanie_kierowcow_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                                    mime="text/csv"
                                )

                        with col_export2:
                            if st.button("üì• Pobierz podsumowanie (Excel)"):
                                output_summary = io.BytesIO()
                                with pd.ExcelWriter(output_summary, engine='openpyxl') as writer:
                                    summary_df.to_excel(
                                        writer, sheet_name='Podsumowanie', index=False)
                                output_summary.seek(0)

                                st.download_button(
                                    label="üì• Pobierz Excel",
                                    data=output_summary.getvalue(),
                                    file_name=f"podsumowanie_kierowcow_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx",
                                    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                                )

                        st.markdown("---")
                        st.subheader("üìä Szczeg√≥≈Çowe dane")
                        st.dataframe(df.head(10), use_container_width=True)
                    else:
                        st.header("üìä Wszystkie dane")
                        st.dataframe(df.head(10), use_container_width=True)

            with col2:
                st.header("üíæ Eksport")

                # Eksport danych - tylko gdy wybrano konkretnego kierowcƒô
                if 'Driver ID:' in df.columns and selected_driver != 'Wszyscy':
                    # Eksport danych
                    if st.button("Pobierz dane (CSV)"):
                        csv = df.to_csv(index=False)
                        st.download_button(
                            label="üì• Pobierz CSV",
                            data=csv,
                            file_name=f"dane_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                            mime="text/csv"
                        )

                    if st.button("Pobierz dane (Excel)"):
                        output = io.BytesIO()
                        with pd.ExcelWriter(output, engine='openpyxl') as writer:
                            df.to_excel(writer, sheet_name='Dane', index=False)
                        output.seek(0)

                        st.download_button(
                            label="üì• Pobierz Excel",
                            data=output.getvalue(),
                            file_name=f"dane_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx",
                            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                        )
                else:
                    st.info(
                        "üí° Wybierz konkretnego kierowcƒô, aby eksportowaƒá szczeg√≥≈Çowe dane")
                    st.info("üìã U≈ºyj przycisk√≥w eksportu podsumowania poni≈ºej")

            # Wy≈õwietl dane
            st.markdown("---")
            st.subheader("üìã Dane")
            st.dataframe(df, use_container_width=True)

else:
    # Instrukcje gdy nie ma pliku
    st.info("üëÜ Za≈Çaduj plik Excel, aby rozpoczƒÖƒá przetwarzanie danych.")

    st.markdown("""
    ## üöÄ Funkcje aplikacji:
    
    - **üìÅ ≈Åadowanie plik√≥w Excel** - obs≈Çuga format√≥w .xlsx, .xls i .xlsb
    - **üìÖ Wyb√≥r dat** - kalendarz z opcjami: wszystkie daty, tylko soboty, niestandardowy wyb√≥r (zapamiƒôtuje wyb√≥r)
    - **üöó Wyb√≥r Driver ID** - filtrowanie danych wed≈Çug kierowcy z skr√≥conymi nazwami (zapamiƒôtuje wyb√≥r)
    - **‚ö†Ô∏è Exception info** - multiselect z zahardkodowanymi warto≈õciami: DR RELEASED, COMM INS REL, SIG OBTAINED
    - **üìä PodglƒÖd danych** - wy≈õwietlanie pierwszych 10 wierszy
    - **üíæ Eksport** - pobieranie danych w formacie CSV lub Excel
    
    ## üìù Jak u≈ºywaƒá:
    1. Za≈Çaduj plik Excel u≈ºywajƒÖc przycisku w lewym panelu
    2. Wybierz opcjƒô dat (wszystkie, tylko soboty, lub niestandardowy wyb√≥r) - wyb√≥r zostanie zapamiƒôtany
    3. Wybierz Driver ID z listy rozwijanej - wyb√≥r zostanie zapamiƒôtany
    4. Wybierz z zahardkodowanych warto≈õci Exception info: DR RELEASED, COMM INS REL, SIG OBTAINED
    5. Przejrzyj dane
    6. Eksportuj wyniki w formacie CSV lub Excel
    
    ## ‚ú® Nowe funkcje:
    - **Skr√≥cone nazwy Driver ID** - wy≈õwietlanie tylko znak√≥w 5-8 z nazwy dla lepszej czytelno≈õci
    - **Sortowanie** - Driver ID sƒÖ posortowane numerycznie lub alfabetycznie
    - **Tabela podsumowujƒÖca** - pokazuje skr√≥conƒÖ nazwƒô + oryginalnƒÖ w nawiasach
    """)

# Stopka
st.markdown("---")
st.markdown(
    "üí° **Wskaz√≥wka:** Aplikacja automatycznie cache'uje za≈Çadowane pliki dla lepszej wydajno≈õci.")
